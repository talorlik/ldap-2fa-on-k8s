<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LDAP 2FA on Kubernetes - Documentation</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="stylesheet" href="light-theme.css" id="theme-stylesheet">
</head>
<body>
    <!-- Sticky Navigation -->
    <nav class="navbar">
        <div class="nav-container">
            <a href="#hero" class="nav-logo">LDAP 2FA on K8s</a>
            <button class="mobile-menu-toggle" id="mobileMenuToggle">‚ò∞</button>
            <ul class="nav-menu" id="navMenu">
                <li><a href="#content-index">Content Index</a></li>
                <li><a href="#overview">Overview</a></li>
                <li><a href="#getting-started">Getting Started</a></li>
                <li><a href="#architecture">Architecture</a></li>
                <li><a href="#documentation">Documentation</a></li>
                <li><a href="#access">Access</a></li>
                <li><a href="#security">Security</a></li>
                <li><a href="#support">Support</a></li>
                <li>
                    <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
                        <span class="icon" id="sunIcon" title="Switch to light theme">‚òÄÔ∏è</span>
                        <span class="icon hidden" id="moonIcon" title="Switch to dark theme">üåô</span>
                    </button>
                </li>
            </ul>
        </div>
    </nav>
    <!-- Hero Section -->
    <section id="hero" class="hero">
        <div class="hero-content">
            <h1>LDAP Authentication with 2FA on Kubernetes</h1>
            <p>Complete LDAP authentication solution with two-factor authentication, self-service password management, and GitOps capabilities on Amazon EKS</p>
            <img src="header_banner.png" alt="Project Banner" class="hero-banner">
        </div>
    </section>
    <!-- Content Index -->
    <section id="content-index">
        <h2>Content Index</h2>
        <div class="card">
            <ul>
                <li><a href="#overview">Project Overview</a>
                    <ul>
                        <li><a href="#core-infrastructure">Core Infrastructure</a></li>
                        <li><a href="#ldap-stack">LDAP Stack</a></li>
                        <li><a href="#2fa-application">2FA Application</a></li>
                        <li><a href="#supporting-infrastructure">Supporting Infrastructure</a></li>
                        <li><a href="#devops-security">DevOps & Security</a></li>
                        <li><a href="#key-features">Key Features</a></li>
                    </ul>
                </li>
                <li><a href="#getting-started">Getting Started</a>
                    <ul>
                        <li><a href="#prerequisites">Prerequisites</a></li>
                        <li><a href="#deployment-options">Deployment Options</a>
                            <ul>
                                <li><a href="#local-deployment">Local Deployment</a>
                                    <ul>
                                        <li><a href="#local-step-1">Step 1: Deploy Terraform Backend State Infrastructure</a></li>
                                        <li><a href="#local-step-2">Step 2: Deploy Backend Infrastructure</a></li>
                                        <li><a href="#local-step-3">Step 3: Deploy Application Infrastructure</a></li>
                                        <li><a href="#local-step-4">Step 4: Deploy 2FA Applications (Backend and Frontend)</a></li>
                                        <li><a href="#local-destroy">Destroying Infrastructure (Local)</a></li>
                                    </ul>
                                </li>
                                <li><a href="#github-actions-deployment">GitHub Actions Deployment</a>
                                    <ul>
                                        <li><a href="#github-step-1">Step 1: Deploy Terraform Backend State Infrastructure</a></li>
                                        <li><a href="#github-step-2">Step 2: Deploy Backend Infrastructure</a></li>
                                        <li><a href="#github-step-3">Step 3: Deploy Application Infrastructure</a></li>
                                        <li><a href="#github-step-4">Step 4: Deploy 2FA Applications (Backend and Frontend)</a></li>
                                        <li><a href="#github-destroy">Destroying Infrastructure (GitHub Actions)</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li><a href="#deployment-comparison">Deployment Comparison</a></li>
                        <li><a href="#deployment-order">Deployment Order</a></li>
                    </ul>
                </li>
                <li><a href="#architecture">Architecture</a>
                    <ul>
                        <li><a href="#multi-account-architecture">Multi-Account Architecture</a></li>
                        <li><a href="#how-it-works">How It Works</a></li>
                        <li><a href="#project-structure">Project Structure</a></li>
                        <li><a href="#backend-infrastructure-components">Backend Infrastructure Components</a></li>
                        <li><a href="#application-infrastructure-components">Application Infrastructure Components</a></li>
                    </ul>
                </li>
                <li><a href="#documentation">Documentation</a>
                    <ul>
                        <li><a href="#infrastructure-documentation">Infrastructure Documentation</a></li>
                        <li><a href="#application-documentation">Application Documentation</a></li>
                        <li><a href="#module-documentation">Module Documentation</a></li>
                        <li><a href="#configuration-documentation">Configuration Documentation</a></li>
                        <li><a href="#security-operations">Security & Operations</a></li>
                    </ul>
                </li>
                <li><a href="#access">Accessing the Services</a>
                    <ul>
                        <li><a href="#2fa-application-access">2FA Application</a></li>
                        <li><a href="#phpldapadmin-access">PhpLdapAdmin</a></li>
                        <li><a href="#ltb-passwd-access">LTB-passwd</a></li>
                        <li><a href="#argocd-access">ArgoCD</a></li>
                        <li><a href="#ldap-service-access">LDAP Service</a></li>
                        <li><a href="#mfa-methods">MFA Methods</a></li>
                    </ul>
                </li>
                <li><a href="#security">Security Considerations</a>
                    <ul>
                        <li><a href="#key-security-features">Key Security Features</a></li>
                    </ul>
                </li>
                <li><a href="#support">Contributing & Support</a>
                    <ul>
                        <li><a href="#operations-monitoring">Operations & Monitoring</a></li>
                        <li><a href="#troubleshooting">Troubleshooting</a></li>
                        <li><a href="#repository">Repository</a></li>
                        <li><a href="#license">License</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </section>
    <!-- Project Overview -->
    <section id="overview">
        <h2>Project Overview</h2>
        <div class="card">
            <p>This project deploys a complete LDAP authentication solution with two-factor authentication (2FA), self-service password management, and GitOps capabilities on Amazon EKS using Terraform.</p>
        </div>
        <h3 id="core-infrastructure">Core Infrastructure</h3>
        <div class="card">
            <ul>
                <li><strong>EKS Cluster</strong> (Auto Mode) with IRSA for secure pod-to-AWS-service authentication</li>
                <li><strong>VPC</strong> with public/private subnets and VPC endpoints for private AWS service access</li>
                <li><strong>Application Load Balancer (ALB)</strong> via EKS Auto Mode for internet-facing access</li>
                <li><strong>Route53 DNS</strong> integration for domain management</li>
                <li><strong>ACM Certificates</strong> for HTTPS/TLS termination</li>
            </ul>
        </div>
        <h3 id="ldap-stack">LDAP Stack</h3>
        <div class="card">
            <ul>
                <li><strong>OpenLDAP Stack</strong> with high availability and multi-master replication</li>
                <li><strong>PhpLdapAdmin</strong> web interface for LDAP administration</li>
                <li><strong>LTB-passwd</strong> self-service password management UI</li>
            </ul>
        </div>
        <h3 id="2fa-application">2FA Application</h3>
        <div class="card">
            <ul>
                <li><strong>Full-stack 2FA application</strong> with Python FastAPI backend and static HTML/JS/CSS frontend</li>
                <li><strong>Dual MFA methods</strong>: TOTP (authenticator apps) and SMS (AWS SNS)</li>
                <li><strong>LDAP integration</strong> for centralized user authentication</li>
                <li><strong>Self-service user registration</strong> with email/phone verification and profile state management</li>
                <li><strong>Admin dashboard</strong> for user management, group CRUD operations, and approval workflows</li>
                <li><strong>User profile management</strong> with edit restrictions for verified fields</li>
                <li><strong>Interactive API documentation</strong> via Swagger UI and ReDoc (always enabled)</li>
            </ul>
        </div>
        <h3 id="supporting-infrastructure">Supporting Infrastructure</h3>
        <div class="card">
            <ul>
                <li><strong>PostgreSQL</strong> (Bitnami Helm chart, OCI registry) for user registration data and email verification token storage with persistent EBS-backed storage</li>
                <li><strong>Redis</strong> (Bitnami Helm chart) for SMS OTP code storage with TTL-based automatic expiration and shared state across replicas</li>
                <li><strong>AWS SES</strong> for email verification and notifications with IRSA-based access (no hardcoded credentials)</li>
                <li><strong>AWS SNS</strong> for SMS-based 2FA verification (optional, requires SNS VPC endpoint enabled in backend infrastructure)</li>
            </ul>
        </div>
        <h3 id="devops-security">DevOps & Security</h3>
        <div class="card">
            <ul>
                <li><strong>ArgoCD</strong> (AWS EKS managed service) for GitOps deployments with AWS Identity Center authentication</li>
                <li><strong>cert-manager</strong> for automatic TLS certificate management</li>
                <li><strong>Network Policies</strong> for securing pod-to-pod communication with cross-namespace support</li>
                <li><strong>IRSA</strong> (IAM Roles for Service Accounts) for secure AWS API access from pods without credentials</li>
                <li><strong>VPC Endpoints</strong> for private AWS service access (SSM, STS, SNS) without internet exposure</li>
                <li><strong>Multi-Account Architecture</strong> with separated state storage and deployment accounts</li>
                <li><strong>S3 File-Based Locking</strong> for Terraform state management (migrated from DynamoDB)</li>
            </ul>
        </div>
        <h3 id="key-features">Key Features</h3>
        <div class="card">
            <ul>
                <li><strong>EKS Auto Mode</strong>: Simplified cluster management with automatic load balancer provisioning and built-in EBS CSI driver</li>
                <li><strong>Two-Factor Authentication</strong>: Full-stack 2FA application with dual MFA methods (TOTP and SMS)</li>
                <li><strong>Self-Service User Registration</strong>: Email and phone verification with profile state management (PENDING ‚Üí COMPLETE ‚Üí ACTIVE)</li>
                <li><strong>Admin Dashboard</strong>: User management, group CRUD operations, approval workflows, and user profile management</li>
                <li><strong>IRSA Integration</strong>: Secure AWS API access from pods without hardcoded credentials via OIDC</li>
                <li><strong>High Availability</strong>: Multi-master OpenLDAP replication with persistent storage</li>
                <li><strong>GitOps Ready</strong>: ArgoCD (AWS managed service) for declarative, Git-driven deployments</li>
                <li><strong>Multi-Account Architecture</strong>: Separation of state storage (Account A) and resource deployment (Account B) for enhanced security</li>
                <li><strong>API Documentation</strong>: Interactive Swagger UI and ReDoc always available at <code>/api/docs</code> and <code>/api/redoc</code> (always enabled, not just in debug mode)</li>
                <li><strong>Secrets Management</strong>: Passwords managed via GitHub repository secrets (for CI/CD) or AWS Secrets Manager (for local deployment) with automated retrieval</li>
                <li><strong>Public ACM Certificates</strong>: Uses public ACM certificates (Amazon-issued) with DNS validation for browser-trusted certificates (no security warnings)</li>
                <li><strong>Route53 Record Module</strong>: Dedicated module for Route53 A (alias) records with cross-account support and ALB zone_id mapping</li>
            </ul>
        </div>
    </section>
    <!-- Getting Started -->
    <section id="getting-started">
        <h2>Getting Started</h2>
        <h3 id="prerequisites">Prerequisites</h3>
        <div class="card">
            <ul>
                <li><strong>AWS Account(s)</strong> with appropriate permissions
                    <ul>
                        <li><strong>State Account (Account A)</strong>: For Terraform state storage (S3)</li>
                        <li><strong>Deployment Account (Account B)</strong>: For infrastructure resources (EKS, ALB, Route53, etc.)</li>
                    </ul>
                </li>
                <li><strong>GitHub Account</strong> and repository fork: <a href="https://github.com/talorlik/ldap-2fa-on-k8s.git" target="_blank">ldap-2fa-on-k8s</a></li>
                <li><strong>AWS SSO/OIDC</strong> configured (see <a href="../README.md#github-repository-configuration">GitHub Repository Configuration</a>)</li>
                <li><strong>Route53 hosted zone</strong> must already exist (or create it manually)
                    <ul>
                        <li>Can be in State Account (different from deployment account) - automatically accessed via <code>state_account_role_arn</code></li>
                        <li>See <a href="../application/CROSS-ACCOUNT-ACCESS.md">Cross-Account Access Documentation</a> for details</li>
                    </ul>
                </li>
                <li><strong>Public ACM Certificate Setup</strong>: Public ACM certificates must be requested in each deployment account and validated using DNS records in the State Account's Route53 hosted zone
                    <ul>
                        <li>See <a href="../application/CROSS-ACCOUNT-ACCESS.md#public-acm-certificate-setup-and-dns-validation">Public ACM Certificate Setup and DNS Validation</a> for detailed setup instructions</li>
                        <li>Includes step-by-step AWS CLI commands for requesting certificates, creating DNS validation records, and verifying certificate status</li>
                        <li>Each deployment account (development, production) has its own public ACM certificate</li>
                        <li>Certificates are automatically renewed by ACM</li>
                    </ul>
                </li>
                <li><strong>ACM certificate</strong> must already exist and be validated in the same region as the EKS cluster
                    <ul>
                        <li>Certificate must be a public ACM certificate (Amazon-issued) requested in the Deployment Account</li>
                        <li>Certificate must exist in the Deployment Account (not State Account)</li>
                        <li>Certificate must be validated and in <code>ISSUED</code> status</li>
                        <li>DNS validation records must be created in Route53 hosted zone in the State Account</li>
                        <li>See <a href="../application/CROSS-ACCOUNT-ACCESS.md">Cross-Account Access Documentation</a> for details</li>
                    </ul>
                </li>
                <li><strong>GitHub Secrets and Variables</strong> configured (see <a href="../SECRETS_REQUIREMENTS.md">Secrets Requirements</a> for complete details):
                    <ul>
                        <li><strong>Required Secrets:</strong>
                            <ul>
                                <li><code>AWS_STATE_ACCOUNT_ROLE_ARN</code></li>
                                <li><code>AWS_PRODUCTION_ACCOUNT_ROLE_ARN</code></li>
                                <li><code>AWS_DEVELOPMENT_ACCOUNT_ROLE_ARN</code></li>
                                <li><code>AWS_ASSUME_EXTERNAL_ID</code></li>
                                <li><code>TF_VAR_OPENLDAP_ADMIN_PASSWORD</code></li>
                                <li><code>TF_VAR_OPENLDAP_CONFIG_PASSWORD</code></li>
                                <li><code>TF_VAR_REDIS_PASSWORD</code></li>
                                <li><code>TF_VAR_POSTGRESQL_PASSWORD</code></li>
                                <li><code>GH_TOKEN</code></li>
                            </ul>
                        </li>
                        <li><strong>Required Variables:</strong>
                            <ul>
                                <li><code>AWS_REGION</code></li>
                                <li><code>BACKEND_PREFIX</code></li>
                                <li><code>APPLICATION_PREFIX</code></li>
                            </ul>
                        </li>
                        <li><strong>Auto-generated Variables:</strong> (set automatically by workflows/scripts)
                            <ul>
                                <li><code>BACKEND_BUCKET_NAME</code> - Set by Terraform backend state provisioning</li>
                                <li><code>ECR_REPOSITORY_NAME</code> - Set by backend infrastructure provisioning</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><strong>For Local Deployment:</strong> GitHub CLI (<code>gh</code>), AWS CLI, Terraform, kubectl, and <code>jq</code> installed and configured</li>
                <li><strong>For Local Deployment:</strong> <strong>Docker</strong> must be installed and running for ECR image mirroring. The <code>mirror-images-to-ecr.sh</code> script requires Docker to pull images from Docker Hub and push them to ECR. This step is automatically executed by <code>setup-application.sh</code> before Terraform operations.</li>
                <li><strong>For Local Deployment:</strong> AWS Secrets Manager configured with <code>github-role</code>, <code>tf-vars</code>, and <code>external-id</code> secrets (see <a href="../SECRETS_REQUIREMENTS.md">Secrets Requirements</a>)</li>
            </ul>
            <p><strong>For detailed prerequisites and setup:</strong> <a href="../README.md#prerequisites">Prerequisites</a> | <a href="../README.md#secrets-configuration">Secrets Configuration</a> | <a href="../SECRETS_REQUIREMENTS.md">Secrets Requirements</a></p>
        </div>
        <h3 id="deployment-options">Deployment Options</h3>
        <div class="deployment-options">
            <div class="deployment-card">
                <h4 id="local-deployment">Local Deployment</h4>
                <p><strong>Recommended for:</strong> Development, testing, and local experimentation</p>
                <h5 id="local-step-1">Step 1: Deploy Terraform Backend State Infrastructure</h5>
                <p>Deploy the S3 bucket for Terraform state storage:</p>
                <pre><code>cd tf_backend_state
./set-state.sh</code></pre>
                <p><strong>What the script does:</strong></p>
                <ul>
                    <li>Retrieves <code>AWS_STATE_ACCOUNT_ROLE_ARN</code> from AWS Secrets Manager</li>
                    <li>Retrieves <code>AWS_REGION</code> and <code>BACKEND_PREFIX</code> from GitHub repository variables</li>
                    <li>Assumes the IAM role and verifies credentials</li>
                    <li>Checks if infrastructure exists (via <code>BACKEND_BUCKET_NAME</code> variable)</li>
                    <li>If new: Runs Terraform init, validate, plan, and apply to create S3 bucket</li>
                    <li>If exists: Downloads existing state file from S3 (if available)</li>
                    <li>Saves/updates <code>BACKEND_BUCKET_NAME</code> to GitHub repository variables</li>
                    <li>Uploads state file to S3</li>
                </ul>
                <p><strong>Alternative:</strong> Use <code>./get-state.sh</code> to download existing state file without provisioning</p>
                <h5 id="local-step-2">Step 2: Deploy Backend Infrastructure</h5>
                <p>Deploy VPC, EKS cluster, VPC endpoints, IRSA, and ECR:</p>
                <pre><code>cd backend_infra
./setup-backend.sh</code></pre>
                <p><strong>What the script does:</strong></p>
                <ul>
                    <li>Prompts for AWS region (us-east-1 or us-east-2) and environment (prod or dev)</li>
                    <li>Retrieves repository variables from GitHub (<code>BACKEND_BUCKET_NAME</code>, <code>BACKEND_PREFIX</code>)</li>
                    <li>Retrieves role ARNs from AWS Secrets Manager (<code>github-role</code> secret)</li>
                    <li>Retrieves ExternalId from AWS Secrets Manager (<code>external-id</code> secret)</li>
                    <li>Assumes State Account role for backend operations</li>
                    <li>Generates <code>backend.hcl</code> from template (if it doesn't exist)</li>
                    <li>Updates <code>variables.tfvars</code> with selected region, environment, deployment account role ARN, and ExternalId</li>
                    <li>Runs Terraform init, workspace select/new, validate, plan, and apply</li>
                </ul>
                <h5 id="local-step-3">Step 3: Deploy Application Infrastructure</h5>
                <p>Deploy OpenLDAP stack, 2FA application, ALB, Route53 records, and supporting services:</p>
                <pre><code>cd application
./setup-application.sh</code></pre>
                <p><strong>What the script does:</strong></p>
                <ul>
                    <li>Prompts for AWS region (us-east-1 or us-east-2) and environment (prod or dev)</li>
                    <li>Retrieves repository variables from GitHub (<code>BACKEND_BUCKET_NAME</code>, <code>APPLICATION_PREFIX</code>)</li>
                    <li><strong>Mirrors Docker images to ECR</strong> (runs <code>mirror-images-to-ecr.sh</code> before Terraform operations):
                        <ul>
                            <li>Checks if images exist in ECR before mirroring (skips if already present)</li>
                            <li>Pulls images from Docker Hub: <code>bitnami/redis:8.4.0-debian-12-r6</code>, <code>bitnami/postgresql:18.1.0-debian-12-r4</code>, <code>osixia/openldap:1.5.0</code></li>
                            <li>Pushes images to ECR with tags: <code>redis-latest</code>, <code>postgresql-latest</code>, <code>openldap-1.5.0</code></li>
                            <li>Uses State Account credentials to fetch ECR URL from backend_infra state</li>
                            <li>Assumes Deployment Account role for ECR operations (with ExternalId)</li>
                            <li>Authenticates Docker to ECR automatically</li>
                            <li>Cleans up local images after pushing to save disk space</li>
                            <li>Requires Docker to be installed and running</li>
                            <li>Requires <code>jq</code> for JSON parsing (with fallback to sed for compatibility)</li>
                        </ul>
                    </li>
                    <li>Retrieves role ARNs and ExternalId from AWS Secrets Manager</li>
                    <li>Retrieves password secrets from AWS Secrets Manager (<code>tf-vars</code> secret) and exports as environment variables:
                        <ul>
                            <li><code>TF_VAR_openldap_admin_password</code></li>
                            <li><code>TF_VAR_openldap_config_password</code></li>
                            <li><code>TF_VAR_postgresql_database_password</code></li>
                            <li><code>TF_VAR_redis_password</code></li>
                        </ul>
                    </li>
                    <li>Assumes State Account role for backend operations</li>
                    <li>Generates <code>backend.hcl</code> from template (if it doesn't exist)</li>
                    <li>Updates <code>variables.tfvars</code> with selected values</li>
                    <li>Sets Kubernetes environment variables using <code>set-k8s-env.sh</code></li>
                    <li>Runs Terraform init, workspace select/new, validate, plan, and apply</li>
                </ul>
                <h5 id="local-step-4">Step 4: Deploy 2FA Applications (Backend and Frontend)</h5>
                <p><strong>Prerequisites:</strong> Infrastructure must be deployed (Steps 1-3 completed). Required tools: <code>kubectl</code> configured to access your EKS cluster, <code>helm</code> (v3.x), <code>aws</code> CLI, and optionally <code>docker</code> for manual builds.</p>
                <p><strong>Overview:</strong> The deployment process involves building and pushing Docker images, gathering configuration values, creating namespace, deploying backend and frontend Helm charts, and verifying deployment.</p>
                <h6>4.1: Build and Push Docker Images</h6>
                <p>You have two options for building and pushing images:</p>
                <p><strong>Option A: Using GitHub Actions (Recommended)</strong></p>
                <ol>
                    <li><strong>Build and push backend image:</strong>
                        <ul>
                            <li>Go to GitHub ‚Üí Actions ‚Üí "Backend Build and Push"</li>
                            <li>Click "Run workflow"</li>
                            <li>Select environment (prod or dev)</li>
                            <li>Click "Run workflow"</li>
                            <li>Wait for the workflow to complete</li>
                            <li>Note the image tag from the workflow output (format: <code>ldap-2fa-backend-&lt;commit-sha&gt;</code>)</li>
                        </ul>
                    </li>
                    <li><strong>Build and push frontend image:</strong>
                        <ul>
                            <li>Go to GitHub ‚Üí Actions ‚Üí "Frontend Build and Push"</li>
                            <li>Click "Run workflow"</li>
                            <li>Select environment (prod or dev)</li>
                            <li>Click "Run workflow"</li>
                            <li>Wait for the workflow to complete</li>
                            <li>Note the image tag from the workflow output (format: <code>ldap-2fa-frontend-&lt;commit-sha&gt;</code>)</li>
                        </ul>
                    </li>
                </ol>
                <p>The GitHub Actions workflows automatically build Docker images, push to ECR, update Helm values.yaml files with new image tags, and commit changes to the repository.</p>
                <p><strong>Option B: Manual Build and Push</strong></p>
                <pre><code># Set variables
export AWS_REGION="us-east-1"
export ECR_REPO_NAME="talo-tf-us-east-1-docker-images-prod"  # Adjust based on your setup
export AWS_ACCOUNT_ID="944880695150"  # Your deployment account ID

# Get ECR login
aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com

# Build and push backend
cd application/backend
docker build -t ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}:ldap-2fa-backend-$(git rev-parse --short HEAD) .
docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}:ldap-2fa-backend-$(git rev-parse --short HEAD)

# Build and push frontend
cd ../frontend
docker build -t ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}:ldap-2fa-frontend-$(git rev-parse --short HEAD) .
docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}:ldap-2fa-frontend-$(git rev-parse --short HEAD)</code></pre>
                <h6>4.2: Gather Required Configuration Values</h6>
                <p>Get the required values from Terraform outputs:</p>
                <pre><code>cd application

# Get IngressClass name
INGRESS_CLASS=$(terraform output -raw alb_ingress_class_name)
echo "IngressClass: ${INGRESS_CLASS}"

# Get ALB load balancer name (from variables.tfvars or compute it)
# Format: ${prefix}-${region}-${alb_load_balancer_name}-${env}
PREFIX="talo-tf"
REGION="us-east-1"
ALB_LB_NAME="alb"
ENV="prod"
ALB_NAME="${PREFIX}-${REGION}-${ALB_LB_NAME}-${ENV}"
# Truncate to 32 chars if needed
ALB_NAME=$(echo "${ALB_NAME}" | cut -c1-32)
echo "ALB Name: ${ALB_NAME}"

# Get hostname
HOSTNAME="app.talorlik.com"  # From variables.tfvars: twofa_app_host
echo "Hostname: ${HOSTNAME}"

# Get ECR repository URL
ECR_URL=$(terraform output -raw ecr_url 2>/dev/null || echo "")
if [ -z "$ECR_URL" ]; then
  echo "ECR URL not found in Terraform outputs."
  echo "Make sure backend_infra has been deployed and outputs ecr_url."
  exit 1
fi
echo "ECR URL: ${ECR_URL}"

# Get image tags (from GitHub Actions or latest commit)
BACKEND_TAG="ldap-2fa-backend-$(git rev-parse --short HEAD)"  # Or use tag from GitHub Actions
FRONTEND_TAG="ldap-2fa-frontend-$(git rev-parse --short HEAD)"  # Or use tag from GitHub Actions
echo "Backend Tag: ${BACKEND_TAG}"
echo "Frontend Tag: ${FRONTEND_TAG}"

# Get SES IAM Role ARN (for IRSA)
SES_ROLE_ARN=$(terraform output -raw ses_iam_role_arn 2>/dev/null || echo "")
echo "SES Role ARN: ${SES_ROLE_ARN}"

# Get SNS IAM Role ARN (for IRSA, if SMS 2FA is enabled)
SNS_ROLE_ARN=$(terraform output -raw sns_iam_role_arn 2>/dev/null || echo "")
echo "SNS Role ARN: ${SNS_ROLE_ARN}"

# Get domain name
DOMAIN_NAME=$(terraform output -raw route53_domain_name)
echo "Domain: ${DOMAIN_NAME}"

# Get PostgreSQL connection info
POSTGRES_HOST=$(terraform output -raw postgresql_host)
echo "PostgreSQL Host: ${POSTGRES_HOST}"

# Get Redis connection info
REDIS_HOST=$(terraform output -raw redis_host)
REDIS_PORT=$(terraform output -raw redis_port)
echo "Redis Host: ${REDIS_HOST}:${REDIS_PORT}"

# Get SES sender email
SES_SENDER_EMAIL=$(terraform output -raw ses_sender_email)
echo "SES Sender: ${SES_SENDER_EMAIL}"

# Get SNS topic ARN (if SMS 2FA is enabled)
SNS_TOPIC_ARN=$(terraform output -raw sns_topic_arn 2>/dev/null || echo "")
echo "SNS Topic ARN: ${SNS_TOPIC_ARN}"</code></pre>
                <h6>4.3: Create Namespace</h6>
                <pre><code>kubectl create namespace 2fa-app</code></pre>
                <h6>4.4: Deploy Backend Application</h6>
                <p>Create a values file for the backend deployment:</p>
                <pre><code>cat > /tmp/backend-values.yaml <<EOF
# Image configuration
image:
  repository: "${ECR_URL}"
  tag: "${BACKEND_TAG}"

# Ingress configuration
ingress:
  enabled: true
  className: "${INGRESS_CLASS}"
  annotations:
    alb.ingress.kubernetes.io/load-balancer-name: "${ALB_NAME}"
  hosts:
    - host: "${HOSTNAME}"
      paths:
        - path: /api
          pathType: Prefix

# Service account with IRSA annotation
serviceAccount:
  annotations:
    eks.amazonaws.com/role-arn: "${SES_ROLE_ARN}"  # Use SES role (includes SNS if enabled)

# LDAP configuration (adjust based on your LDAP setup)
ldap:
  host: "openldap-stack-ha.ldap.svc.cluster.local"
  port: 389
  baseDn: "dc=ldap,dc=talorlik,dc=internal"
  adminDn: "cn=admin,dc=ldap,dc=talorlik,dc=internal"

# Database configuration
database:
  url: "postgresql+asyncpg://ldap2fa:CHANGE_ME@${POSTGRES_HOST}:5432/ldap2fa"
  externalSecret:
    enabled: true
    secretName: "postgresql-secret"
    passwordKey: "password"

# Email configuration
email:
  enabled: true
  senderEmail: "${SES_SENDER_EMAIL}"
  appUrl: "https://${HOSTNAME}"

# SMS configuration (if enabled)
sms:
  enabled: true  # Set to false if SMS 2FA is not enabled
  awsRegion: "${REGION}"
  snsTopicArn: "${SNS_TOPIC_ARN}"

# Redis configuration (if SMS is enabled)
redis:
  enabled: true  # Set to false if SMS 2FA is not enabled
  host: "${REDIS_HOST}"
  port: ${REDIS_PORT}
  existingSecret:
    enabled: true
    name: "redis-secret"
    key: "redis-password"
EOF</code></pre>
                <p>Deploy the backend:</p>
                <pre><code>cd application/backend/helm

helm upgrade --install ldap-2fa-backend ldap-2fa-backend \
  --namespace 2fa-app \
  --create-namespace \
  --values /tmp/backend-values.yaml \
  --wait \
  --timeout 10m</code></pre>
                <h6>4.5: Deploy Frontend Application</h6>
                <p>Create a values file for the frontend deployment:</p>
                <pre><code>cat > /tmp/frontend-values.yaml <<EOF
# Image configuration
image:
  repository: "${ECR_URL}"
  tag: "${FRONTEND_TAG}"

# Ingress configuration
ingress:
  enabled: true
  className: "${INGRESS_CLASS}"
  annotations:
    alb.ingress.kubernetes.io/load-balancer-name: "${ALB_NAME}"
  hosts:
    - host: "${HOSTNAME}"
      paths:
        - path: /
          pathType: Prefix
EOF</code></pre>
                <p>Deploy the frontend:</p>
                <pre><code>cd application/frontend/helm

helm upgrade --install ldap-2fa-frontend ldap-2fa-frontend \
  --namespace 2fa-app \
  --create-namespace \
  --values /tmp/frontend-values.yaml \
  --wait \
  --timeout 10m</code></pre>
                <h6>4.6: Verify Deployment</h6>
                <pre><code># Check pods
kubectl get pods -n 2fa-app

# Check services
kubectl get svc -n 2fa-app

# Check ingress
kubectl get ingress -n 2fa-app

# Check backend logs
kubectl logs -n 2fa-app -l app=ldap-2fa-backend --tail=50

# Check frontend logs
kubectl logs -n 2fa-app -l app=ldap-2fa-frontend --tail=50

# Test backend health endpoint
kubectl run -it --rm test-backend --image=curlimages/curl --restart=Never -- \
  curl -k https://${HOSTNAME}/api/healthz

# Check ALB target health
ALB_ARN=$(aws elbv2 describe-load-balancers --region ${REGION} --query "LoadBalancers[?LoadBalancerName=='${ALB_NAME}'].LoadBalancerArn" --output text)
TARGET_GROUP_ARN=$(aws elbv2 describe-target-groups --region ${REGION} --load-balancer-arn ${ALB_ARN} --query "TargetGroups[?contains(TargetGroupName, 'backend')].TargetGroupArn" --output text | head -1)
aws elbv2 describe-target-health --region ${REGION} --target-group-arn ${TARGET_GROUP_ARN}</code></pre>
                <h6>4.7: Access the Application</h6>
                <p>Once deployed, access the application at:</p>
                <ul>
                    <li><strong>Frontend:</strong> <code>https://${HOSTNAME}</code> (e.g., <code>https://app.talorlik.com</code>)</li>
                    <li><strong>Backend API:</strong> <code>https://${HOSTNAME}/api</code> (e.g., <code>https://app.talorlik.com/api</code>)</li>
                    <li><strong>API Documentation:</strong> <code>https://${HOSTNAME}/api/docs</code> (Swagger UI)</li>
                </ul>
                <h6>4.8: Updating Deployments</h6>
                <p>To update the applications after code changes:</p>
                <ol>
                    <li><strong>Rebuild and push images</strong> (via GitHub Actions or manually)</li>
                    <li><strong>Update Helm values</strong> with new image tags</li>
                    <li><strong>Upgrade Helm releases:</strong>
                        <pre><code># Update backend
helm upgrade ldap-2fa-backend application/backend/helm/ldap-2fa-backend \
  --namespace 2fa-app \
  --set image.tag="${NEW_BACKEND_TAG}" \
  --reuse-values

# Update frontend
helm upgrade ldap-2fa-frontend application/frontend/helm/ldap-2fa-frontend \
  --namespace 2fa-app \
  --set image.tag="${NEW_FRONTEND_TAG}" \
  --reuse-values</code></pre>
                    </li>
                </ol>
                <h6>4.9: Alternative: Enable ArgoCD Applications</h6>
                <p>If you prefer GitOps deployment via ArgoCD:</p>
                <ol>
                    <li><strong>Enable ArgoCD applications</strong> in <code>variables.tfvars</code>:
                        <pre><code>enable_argocd_apps = true</code></pre>
                    </li>
                    <li><strong>Configure sync policy</strong> (optional):
                        <pre><code>argocd_app_sync_policy_automated = true
argocd_app_sync_policy_prune     = true
argocd_app_sync_policy_self_heal = true</code></pre>
                    </li>
                    <li><strong>Apply Terraform changes:</strong>
                        <pre><code>cd application
terraform apply</code></pre>
                    </li>
                    <li><strong>ArgoCD will automatically deploy</strong> the applications from Git</li>
                </ol>
                <p><strong>For detailed deployment instructions:</strong> <a href="../application/DEPLOY-2FA-APPS.md">Deploying the 2FA Application</a></p>
                <h5 id="local-destroy">Destroying Infrastructure (Local)</h5>
                <p><strong>‚ö†Ô∏è Warning:</strong> Destroy operations are permanent and cannot be undone. Always destroy in reverse order.</p>
                <ol>
                    <li><strong>Destroy Application Infrastructure:</strong>
                        <pre><code>cd application
./destroy-application.sh</code></pre>
                        <p>Script will prompt for region and environment, then require confirmation ('yes', then 'DESTROY')</p>
                    </li>
                    <li><strong>Destroy Backend Infrastructure:</strong>
                        <pre><code>cd backend_infra
./destroy-backend.sh</code></pre>
                        <p>Script will prompt for region and environment, then require confirmation ('yes', then 'DESTROY')</p>
                    </li>
                    <li><strong>Destroy State Backend (if needed):</strong>
                        <pre><code>cd tf_backend_state
./get-state.sh  # Download state file first
terraform plan -var-file="variables.tfvars" -destroy -out terraform.tfplan
terraform apply -auto-approve terraform.tfplan</code></pre>
                    </li>
                </ol>
                <p><strong>For detailed local setup instructions:</strong> <a href="../README.md#method-2-local-development">Local Development Setup</a> | <a href="../tf_backend_state/README.md#option-2-local-execution">Terraform Backend State Local Execution</a></p>
            </div>
            <div class="deployment-card">
                <h4 id="github-actions-deployment">GitHub Actions Deployment</h4>
                <p><strong>Recommended for:</strong> Production deployments, CI/CD pipelines, automated workflows</p>
                <h5 id="github-step-1">Step 1: Deploy Terraform Backend State Infrastructure</h5>
                <ol>
                    <li>Go to GitHub ‚Üí <strong>Actions</strong> tab</li>
                    <li>Select <strong>"TF Backend State Provisioning"</strong> workflow</li>
                    <li>Click <strong>"Run workflow"</strong> ‚Üí <strong>"Run workflow"</strong></li>
                    <li>Monitor the workflow execution</li>
                </ol>
                <p><strong>What the workflow does:</strong></p>
                <ul>
                    <li>Uses <code>AWS_STATE_ACCOUNT_ROLE_ARN</code> secret for OIDC authentication</li>
                    <li>Validates Terraform configuration</li>
                    <li>Creates S3 bucket with versioning and encryption</li>
                    <li>Saves bucket name as <code>BACKEND_BUCKET_NAME</code> repository variable</li>
                    <li>Uploads state file to S3</li>
                </ul>
                <h5 id="github-step-2">Step 2: Deploy Backend Infrastructure</h5>
                <ol>
                    <li>Go to GitHub ‚Üí <strong>Actions</strong> tab</li>
                    <li>Select <strong>"Backend Infra Provisioning"</strong> workflow</li>
                    <li>Click <strong>"Run workflow"</strong></li>
                    <li>Select <strong>region</strong> (us-east-1: N. Virginia or us-east-2: Ohio)</li>
                    <li>Select <strong>environment</strong> (prod or dev)</li>
                    <li>Click <strong>"Run workflow"</strong></li>
                    <li>Monitor the workflow execution</li>
                </ol>
                <p><strong>What the workflow does:</strong></p>
                <ul>
                    <li>Uses <code>AWS_STATE_ACCOUNT_ROLE_ARN</code> for backend state operations</li>
                    <li>Uses environment-specific deployment account role ARN (<code>AWS_PRODUCTION_ACCOUNT_ROLE_ARN</code> or <code>AWS_DEVELOPMENT_ACCOUNT_ROLE_ARN</code>)</li>
                    <li>Uses <code>AWS_ASSUME_EXTERNAL_ID</code> for cross-account role assumption</li>
                    <li>Runs Terraform operations to deploy VPC, EKS, VPC endpoints, IRSA, and ECR</li>
                </ul>
                <h5 id="github-step-3">Step 3: Deploy Application Infrastructure</h5>
                <ol>
                    <li>Go to GitHub ‚Üí <strong>Actions</strong> tab</li>
                    <li>Select <strong>"Application Infra Provisioning"</strong> workflow</li>
                    <li>Click <strong>"Run workflow"</strong></li>
                    <li>Select <strong>region</strong> (us-east-1: N. Virginia or us-east-2: Ohio)</li>
                    <li>Select <strong>environment</strong> (prod or dev)</li>
                    <li>Click <strong>"Run workflow"</strong></li>
                    <li>Monitor the workflow execution</li>
                </ol>
                <p><strong>What the workflow does:</strong></p>
                <ul>
                    <li>Uses <code>AWS_STATE_ACCOUNT_ROLE_ARN</code> for backend state operations</li>
                    <li>Uses environment-specific deployment account role ARN</li>
                    <li>Uses <code>AWS_ASSUME_EXTERNAL_ID</code> for cross-account role assumption</li>
                    <li>Retrieves password secrets from GitHub repository secrets</li>
                    <li>Runs Terraform operations to deploy OpenLDAP, 2FA app, ALB, Route53, and supporting services</li>
                </ul>
                <h5 id="github-step-4">Step 4: Deploy 2FA Applications (Backend and Frontend)</h5>
                <p><strong>Prerequisites:</strong> Infrastructure must be deployed (Steps 1-3 completed). Required tools: <code>kubectl</code> configured to access your EKS cluster, <code>helm</code> (v3.x), and <code>aws</code> CLI.</p>
                <p><strong>Overview:</strong> The deployment process involves building and pushing Docker images, gathering configuration values, creating namespace, deploying backend and frontend Helm charts, and verifying deployment.</p>
                <h6>4.1: Build and Push Docker Images</h6>
                <p><strong>Using GitHub Actions (Recommended)</strong></p>
                <ol>
                    <li><strong>Build and push backend image:</strong>
                        <ul>
                            <li>Go to GitHub ‚Üí Actions ‚Üí "Backend Build and Push"</li>
                            <li>Click "Run workflow"</li>
                            <li>Select environment (prod or dev)</li>
                            <li>Click "Run workflow"</li>
                            <li>Wait for the workflow to complete</li>
                            <li>Note the image tag from the workflow output (format: <code>ldap-2fa-backend-&lt;commit-sha&gt;</code>)</li>
                        </ul>
                    </li>
                    <li><strong>Build and push frontend image:</strong>
                        <ul>
                            <li>Go to GitHub ‚Üí Actions ‚Üí "Frontend Build and Push"</li>
                            <li>Click "Run workflow"</li>
                            <li>Select environment (prod or dev)</li>
                            <li>Click "Run workflow"</li>
                            <li>Wait for the workflow to complete</li>
                            <li>Note the image tag from the workflow output (format: <code>ldap-2fa-frontend-&lt;commit-sha&gt;</code>)</li>
                        </ul>
                    </li>
                </ol>
                <p>The GitHub Actions workflows automatically build Docker images, push to ECR, update Helm values.yaml files with new image tags, and commit changes to the repository.</p>
                <h6>4.2: Gather Required Configuration Values</h6>
                <p>Get the required values from Terraform outputs (run these commands locally or in a GitHub Actions workflow):</p>
                <pre><code>cd application

# Get IngressClass name
INGRESS_CLASS=$(terraform output -raw alb_ingress_class_name)

# Get ALB load balancer name (from variables.tfvars or compute it)
PREFIX="talo-tf"  # From your variables
REGION="us-east-1"  # Your region
ALB_LB_NAME="alb"
ENV="prod"  # or "dev"
ALB_NAME="${PREFIX}-${REGION}-${ALB_LB_NAME}-${ENV}"
ALB_NAME=$(echo "${ALB_NAME}" | cut -c1-32)  # Truncate to 32 chars

# Get hostname (from variables.tfvars: twofa_app_host)
HOSTNAME="app.talorlik.com"  # Adjust to your domain

# Get ECR repository URL
ECR_URL=$(terraform output -raw ecr_url)

# Get image tags (from GitHub Actions workflow output)
BACKEND_TAG="ldap-2fa-backend-&lt;commit-sha&gt;"  # From workflow output
FRONTEND_TAG="ldap-2fa-frontend-&lt;commit-sha&gt;"  # From workflow output

# Get SES IAM Role ARN (for IRSA)
SES_ROLE_ARN=$(terraform output -raw ses_iam_role_arn)

# Get SNS IAM Role ARN (for IRSA, if SMS 2FA is enabled)
SNS_ROLE_ARN=$(terraform output -raw sns_iam_role_arn 2>/dev/null || echo "")

# Get PostgreSQL connection info
POSTGRES_HOST=$(terraform output -raw postgresql_host)

# Get Redis connection info
REDIS_HOST=$(terraform output -raw redis_host)
REDIS_PORT=$(terraform output -raw redis_port)

# Get SES sender email
SES_SENDER_EMAIL=$(terraform output -raw ses_sender_email)

# Get SNS topic ARN (if SMS 2FA is enabled)
SNS_TOPIC_ARN=$(terraform output -raw sns_topic_arn 2>/dev/null || echo "")</code></pre>
                <h6>4.3: Create Namespace</h6>
                <pre><code>kubectl create namespace 2fa-app</code></pre>
                <h6>4.4: Deploy Backend Application</h6>
                <p>Create a values file for the backend deployment (same as local deployment) and deploy:</p>
                <pre><code>cd application/backend/helm

helm upgrade --install ldap-2fa-backend ldap-2fa-backend \
  --namespace 2fa-app \
  --create-namespace \
  --values /tmp/backend-values.yaml \
  --wait \
  --timeout 10m</code></pre>
                <p><strong>Note:</strong> The backend values file should include image configuration, ingress settings, service account with IRSA annotation, LDAP configuration, database configuration, email configuration, SMS configuration (if enabled), and Redis configuration (if SMS is enabled). See <a href="../application/DEPLOY-2FA-APPS.md">Deploying the 2FA Application</a> for the complete values file template.</p>
                <h6>4.5: Deploy Frontend Application</h6>
                <pre><code>cd application/frontend/helm

helm upgrade --install ldap-2fa-frontend ldap-2fa-frontend \
  --namespace 2fa-app \
  --create-namespace \
  --values /tmp/frontend-values.yaml \
  --wait \
  --timeout 10m</code></pre>
                <h6>4.6: Verify Deployment</h6>
                <p>Check deployment status using the same verification commands as local deployment (check pods, services, ingress, logs, health endpoints, and ALB target health).</p>
                <h6>4.7: Access the Application</h6>
                <p>Once deployed, access the application at:</p>
                <ul>
                    <li><strong>Frontend:</strong> <code>https://${HOSTNAME}</code> (e.g., <code>https://app.talorlik.com</code>)</li>
                    <li><strong>Backend API:</strong> <code>https://${HOSTNAME}/api</code> (e.g., <code>https://app.talorlik.com/api</code>)</li>
                    <li><strong>API Documentation:</strong> <code>https://${HOSTNAME}/api/docs</code> (Swagger UI)</li>
                </ul>
                <h6>4.8: Updating Deployments</h6>
                <p>To update the applications after code changes:</p>
                <ol>
                    <li><strong>Rebuild and push images</strong> via GitHub Actions workflows</li>
                    <li><strong>Upgrade Helm releases</strong> with new image tags (same commands as local deployment)</li>
                </ol>
                <h6>4.9: Alternative: Enable ArgoCD Applications</h6>
                <p>If you prefer GitOps deployment via ArgoCD, enable ArgoCD applications in <code>variables.tfvars</code> and apply Terraform changes. ArgoCD will automatically deploy the applications from Git.</p>
                <p><strong>For detailed deployment instructions:</strong> <a href="../application/DEPLOY-2FA-APPS.md">Deploying the 2FA Application</a></p>
                <h5 id="github-destroy">Destroying Infrastructure (GitHub Actions)</h5>
                <p><strong>‚ö†Ô∏è Warning:</strong> Destroy operations are permanent and cannot be undone. Always destroy in reverse order.</p>
                <ol>
                    <li><strong>Destroy Application Infrastructure:</strong>
                        <ul>
                            <li>Go to GitHub ‚Üí <strong>Actions</strong> tab</li>
                            <li>Select <strong>"Application Infra Destroying"</strong> workflow</li>
                            <li>Click <strong>"Run workflow"</strong></li>
                            <li>Select environment (prod or dev) and region</li>
                            <li>Click <strong>"Run workflow"</strong></li>
                        </ul>
                    </li>
                    <li><strong>Destroy Backend Infrastructure:</strong>
                        <ul>
                            <li>Go to GitHub ‚Üí <strong>Actions</strong> tab</li>
                            <li>Select <strong>"Backend Infra Destroying"</strong> workflow</li>
                            <li>Click <strong>"Run workflow"</strong></li>
                            <li>Select environment (prod or dev) and region</li>
                            <li>Click <strong>"Run workflow"</strong></li>
                        </ul>
                    </li>
                    <li><strong>Destroy State Backend (if needed):</strong>
                        <ul>
                            <li>Go to GitHub ‚Üí <strong>Actions</strong> tab</li>
                            <li>Select <strong>"TF Backend State Destroying"</strong> workflow</li>
                            <li>Click <strong>"Run workflow"</strong> ‚Üí <strong>"Run workflow"</strong></li>
                        </ul>
                    </li>
                </ol>
                <p><strong>For detailed GitHub Actions setup:</strong> <a href="../README.md#github-repository-configuration">GitHub Repository Configuration</a> | <a href="../README.md#method-1-github-actions-cicd">GitHub Actions Deployment</a></p>
            </div>
        </div>
        <h3 id="deployment-comparison">Deployment Comparison</h3>
        <table>
            <thead>
                <tr>
                    <th>Feature</th>
                    <th>Local Deployment</th>
                    <th>GitHub Actions</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Setup Complexity</td>
                    <td>Medium (requires local tools)</td>
                    <td>Low (web-based)</td>
                </tr>
                <tr>
                    <td>Best For</td>
                    <td>Development, testing</td>
                    <td>Production, CI/CD</td>
                </tr>
                <tr>
                    <td>Requires GitHub CLI</td>
                    <td>Yes</td>
                    <td>No</td>
                </tr>
                <tr>
                    <td>Requires GitHub Secrets</td>
                    <td>Optional (can use env vars)</td>
                    <td>Required</td>
                </tr>
                <tr>
                    <td>Automation Level</td>
                    <td>Script-based</td>
                    <td>Fully automated</td>
                </tr>
            </tbody>
        </table>
        <h3 id="deployment-order">Deployment Order</h3>
        <div class="card">
            <p>The deployment follows a <strong>three-tier approach</strong> that must be executed in order. Each tier depends on the previous one:</p>
            <ol>
                <li><strong>Deploy Terraform Backend State Infrastructure</strong>
                    <ul>
                        <li><strong>Purpose:</strong> Creates S3 bucket for storing Terraform state files</li>
                        <li><strong>Components:</strong> S3 bucket with versioning, encryption, and file-based locking</li>
                        <li><strong>Account:</strong> State Account (Account A)</li>
                        <li><strong>Local:</strong> <code>cd tf_backend_state && ./set-state.sh</code></li>
                        <li><strong>GitHub Actions:</strong> "TF Backend State Provisioning" workflow</li>
                        <li><strong>See:</strong> <a href="../tf_backend_state/README.md">Terraform Backend State README</a></li>
                    </ul>
                </li>
                <li><strong>Deploy Backend Infrastructure</strong>
                    <ul>
                        <li><strong>Purpose:</strong> Creates foundational AWS infrastructure for Kubernetes workloads</li>
                        <li><strong>Components:</strong> VPC with public/private subnets, EKS cluster (Auto Mode), VPC endpoints (SSM, STS, SNS), IRSA (OIDC provider), ECR repository</li>
                        <li><strong>Account:</strong> Deployment Account (Account B)</li>
                        <li><strong>Prerequisites:</strong> Terraform backend state must be deployed first</li>
                        <li><strong>Local:</strong> <code>cd backend_infra && ./setup-backend.sh</code></li>
                        <li><strong>GitHub Actions:</strong> "Backend Infra Provisioning" workflow</li>
                        <li><strong>See:</strong> <a href="../backend_infra/README.md">Backend Infrastructure README</a></li>
                    </ul>
                </li>
                <li><strong>Deploy Application Infrastructure</strong>
                    <ul>
                        <li><strong>Purpose:</strong> Deploys LDAP stack, supporting services, ALB, Route53 records, and infrastructure for 2FA application on the EKS cluster</li>
                        <li><strong>Components:</strong> OpenLDAP stack (HA), PhpLdapAdmin, LTB-passwd, ALB, Route53 records, PostgreSQL, Redis, SES, SNS (optional), ArgoCD (optional)</li>
                        <li><strong>Account:</strong> Deployment Account (Account B)</li>
                        <li><strong>Prerequisites:</strong> Backend infrastructure (EKS cluster) must be deployed first</li>
                        <li><strong>Additional Requirements:</strong> Route53 hosted zone and ACM certificate must exist
                            <ul>
                                <li>Route53 hosted zone and ACM certificate can be in State Account (different from deployment account)</li>
                                <li>Automatically accessed via <code>state_account_role_arn</code> (injected by scripts/workflows)</li>
                                <li>See <a href="../application/CROSS-ACCOUNT-ACCESS.md">Cross-Account Access Documentation</a> for configuration details</li>
                            </ul>
                        </li>
                        <li><strong>Local:</strong> <code>cd application && ./setup-application.sh</code></li>
                        <li><strong>GitHub Actions:</strong> "Application Infra Provisioning" workflow</li>
                        <li><strong>See:</strong> <a href="../application/README.md">Application Infrastructure README</a></li>
                    </ul>
                </li>
                <li><strong>Deploy 2FA Applications (Backend and Frontend)</strong>
                    <ul>
                        <li><strong>Purpose:</strong> Deploys the 2FA application backend and frontend containers to the EKS cluster</li>
                        <li><strong>Components:</strong> Backend application (Python FastAPI), Frontend application (HTML/JS/CSS + nginx), Helm charts for both applications</li>
                        <li><strong>Account:</strong> Deployment Account (Account B)</li>
                        <li><strong>Prerequisites:</strong> Application infrastructure (Step 3) must be deployed first, including ECR repository, ALB, Route53, PostgreSQL, Redis, SES, and SNS (if SMS is enabled)</li>
                        <li><strong>Process:</strong>
                            <ul>
                                <li>Build and push Docker images to ECR (via GitHub Actions or manually)</li>
                                <li>Gather configuration values from Terraform outputs</li>
                                <li>Create Kubernetes namespace</li>
                                <li>Deploy backend Helm chart with proper values</li>
                                <li>Deploy frontend Helm chart with proper values</li>
                                <li>Verify deployment and access the application</li>
                            </ul>
                        </li>
                        <li><strong>Local:</strong> Follow Step 4 instructions in <a href="#local-step-4">Local Deployment</a> section</li>
                        <li><strong>GitHub Actions:</strong> Use "Backend Build and Push" and "Frontend Build and Push" workflows, then follow Step 4 instructions in <a href="#github-step-4">GitHub Actions Deployment</a> section</li>
                        <li><strong>See:</strong> <a href="../application/DEPLOY-2FA-APPS.md">Deploying the 2FA Application</a> for complete step-by-step guide</li>
                    </ul>
                </li>
            </ol>
            <p><strong>Destroy Order:</strong> Always destroy in <strong>reverse order</strong>: 2FA Applications ‚Üí Application Infrastructure ‚Üí Backend Infrastructure ‚Üí State</p>
            <p><strong>For detailed deployment information:</strong> <a href="../README.md#deployment-methods">Deployment Methods</a> | <a href="../README.md#deployment-overview">Deployment Overview</a></p>
        </div>
    </section>
    <!-- Architecture -->
    <section id="architecture">
        <h2>Architecture</h2>
        <h3 id="multi-account-architecture">Multi-Account Architecture</h3>
        <div class="card">
            <p>This project uses a <strong>multi-account architecture</strong> for enhanced security:</p>
            <ul>
                <li><strong>Account A (State Account)</strong>: Stores Terraform state files in S3
                    <ul>
                        <li>S3 bucket with versioning and server-side encryption (AES256)</li>
                        <li>S3 file-based locking (<code>use_lockfile = true</code>) for state concurrency control</li>
                        <li>GitHub Actions authenticates with Account A via OIDC for backend operations</li>
                        <li>Provides isolation between state storage and resource deployment</li>
                        <li>IAM-based access control with OIDC authentication (no access keys required)</li>
                    </ul>
                </li>
                <li><strong>Account B (Deployment Account)</strong>: Contains all infrastructure resources
                    <ul>
                        <li>EKS cluster, VPC, ALB, Route53, and other AWS resources</li>
                        <li>Separate roles for production and development environments</li>
                        <li>Terraform provider assumes Account B role via cross-account role assumption</li>
                        <li>Provides isolation and separation of concerns</li>
                    </ul>
                </li>
            </ul>
            <p><strong>For detailed architecture documentation:</strong> <a href="../README.md#multi-account-architecture">Multi-Account Architecture</a> | <a href="../tf_backend_state/README.md">Terraform Backend State README</a></p>
        </div>
        <h3 id="how-it-works">How It Works</h3>
        <div class="card">
            <p>The multi-account architecture enables secure separation of concerns:</p>
            <ol>
                <li><strong>GitHub Actions</strong> authenticates with Account A via OIDC (no access keys required) for Terraform backend access</li>
                <li><strong>Terraform backend</strong> uses Account A credentials to read/write state files in S3</li>
                <li><strong>Terraform AWS provider</strong> assumes Account B role (via <code>assume_role</code> with ExternalId) for resource deployment</li>
                <li><strong>Remote state</strong> data sources use Account A credentials to read state from Account A, enabling cross-tier dependencies</li>
            </ol>
            <p>This architecture ensures state files are isolated in a dedicated account while resource deployment uses separate credentials, providing enhanced security and better compliance capabilities.</p>
        </div>
        <h3 id="project-structure">Project Structure</h3>
        <pre><code>ldap-2fa-on-k8s/
‚îú‚îÄ‚îÄ SECRETS_REQUIREMENTS.md  # Secrets management documentation (AWS Secrets Manager & GitHub Secrets)
‚îú‚îÄ‚îÄ tf_backend_state/      # Terraform state backend infrastructure (S3) - Account A
‚îú‚îÄ‚îÄ backend_infra/         # Core AWS infrastructure (VPC, EKS, VPC endpoints, IRSA) - Account B
‚îú‚îÄ‚îÄ application/           # Application infrastructure and deployments - Account B
‚îÇ   ‚îú‚îÄ‚îÄ backend/           # 2FA Backend (Python FastAPI)
‚îÇ   ‚îú‚îÄ‚îÄ frontend/          # 2FA Frontend (HTML/JS/CSS + nginx)
‚îÇ   ‚îú‚îÄ‚îÄ helm/              # Helm values for OpenLDAP stack
‚îÇ   ‚îî‚îÄ‚îÄ modules/           # Terraform modules (ALB, ArgoCD, SNS, cert-manager, etc.)
‚îî‚îÄ‚îÄ .github/workflows/     # GitHub Actions workflows for CI/CD</code></pre>
        <h3 id="backend-infrastructure-components">Backend Infrastructure Components</h3>
        <div class="card">
            <ul>
                <li><strong>VPC</strong> with public and private subnets across multiple availability zones</li>
                <li><strong>EKS Cluster</strong> in Auto Mode with automatic node provisioning and CloudWatch logging</li>
                <li><strong>IRSA (IAM Roles for Service Accounts)</strong> for secure pod-to-AWS-service authentication via OIDC</li>
                <li><strong>VPC Endpoints</strong> for private AWS service access:
                    <ul>
                        <li>SSM endpoints for secure node access (Session Manager)</li>
                        <li>STS endpoint for IRSA (IAM role assumption) - enabled by default</li>
                        <li>SNS endpoint for SMS 2FA (optional, requires <code>enable_sns_endpoint = true</code>)</li>
                    </ul>
                </li>
                <li><strong>ECR Repository</strong> for container image storage with lifecycle policies</li>
                <li><strong>Terraform State Backend</strong> using S3 with file-based locking for state concurrency control (migrated from DynamoDB for simplicity and cost efficiency)</li>
            </ul>
        </div>
        <h3 id="application-infrastructure-components">Application Infrastructure Components</h3>
        <div class="card">
            <ul>
                <li><strong>OpenLDAP Stack HA</strong> deployed via Helm chart with:
                    <ul>
                        <li>OpenLDAP StatefulSet (3 replicas for high availability)</li>
                        <li>PhpLdapAdmin web interface</li>
                        <li>LTB-passwd self-service password management</li>
                    </ul>
                </li>
                <li><strong>2FA Application</strong> with LDAP authentication integration:
                    <ul>
                        <li>Python FastAPI backend with TOTP and SMS MFA support</li>
                        <li>Static HTML/JS/CSS frontend with modern UI</li>
                        <li>Single domain routing (<code>app.&lt;domain&gt;</code>) with path-based access</li>
                        <li>Self-service user registration with email/phone verification</li>
                        <li>Admin dashboard for user management and group operations</li>
                        <li>Interactive API documentation (Swagger UI and ReDoc)</li>
                    </ul>
                </li>
                <li><strong>Application Load Balancer (ALB)</strong> via EKS Auto Mode:
                    <ul>
                        <li>Internet-facing ALB with HTTPS/TLS termination</li>
                        <li>Single ALB handles multiple Ingresses via host-based routing</li>
                        <li>Automatic provisioning via IngressClass and IngressClassParams</li>
                        <li>Certificate ARN and group name configured at cluster level</li>
                    </ul>
                </li>
                <li><strong>PostgreSQL</strong> (Bitnami Helm chart) for user registration and verification token storage</li>
                <li><strong>Redis</strong> (Bitnami Helm chart) for SMS OTP code storage with TTL-based expiration</li>
                <li><strong>AWS SES</strong> integration for email verification and notifications (IRSA-based)</li>
                <li><strong>ArgoCD</strong> (AWS EKS managed service) for GitOps deployments with AWS Identity Center</li>
                <li><strong>cert-manager</strong> for automatic TLS certificate management</li>
                <li><strong>Network Policies</strong> for securing pod-to-pod communication with cross-namespace support</li>
                <li><strong>SNS Integration</strong> for SMS-based 2FA verification (optional, requires VPC endpoint)</li>
                <li><strong>Route53 DNS</strong> records for subdomains pointing to ALB</li>
                <li><strong>Persistent Storage</strong> using EBS-backed StorageClass</li>
            </ul>
            <p><strong>For detailed architecture documentation:</strong> <a href="../backend_infra/README.md">Backend Infrastructure README</a> | <a href="../application/README.md">Application Infrastructure README</a></p>
        </div>
    </section>
    <!-- Documentation Index -->
    <section id="documentation">
        <h2>Documentation</h2>
        <h3 id="infrastructure-documentation">Infrastructure Documentation</h3>
        <div class="doc-grid">
            <div class="doc-item">
                <a href="../tf_backend_state/README.md">Terraform Backend State</a>
                <p>S3 state management and GitHub variable configuration</p>
            </div>
            <div class="doc-item">
                <a href="../backend_infra/README.md">Backend Infrastructure</a>
                <p>VPC, EKS, IRSA, VPC endpoints, and ECR documentation</p>
            </div>
            <div class="doc-item">
                <a href="../application/README.md">Application Infrastructure</a>
                <p>OpenLDAP, 2FA app, ALB, ArgoCD, and deployment instructions</p>
            </div>
        </div>
        <h3 id="application-documentation">Application Documentation</h3>
        <div class="doc-grid">
            <div class="doc-item">
                <a href="../application/PRD-2FA-APP.md">2FA Application PRD</a>
                <p>Product requirements for the 2FA application (API specs, frontend architecture, Swagger UI)</p>
            </div>
            <div class="doc-item">
                <a href="../application/PRD-SIGNUP-MAN.md">User Signup Management PRD</a>
                <p>Self-service user registration with email/phone verification and profile state management</p>
            </div>
            <div class="doc-item">
                <a href="../application/PRD-ADMIN-FUNCS.md">Admin Functions PRD</a>
                <p>Admin dashboard, group CRUD operations, user management, and approval workflows</p>
            </div>
            <div class="doc-item">
                <a href="../application/PRD-SMS-MAN.md">SMS OTP Management PRD</a>
                <p>Redis-based SMS OTP storage with TTL-based automatic expiration</p>
            </div>
            <div class="doc-item">
                <a href="../application/OPENLDAP-README.md">OpenLDAP README</a>
                <p>OpenLDAP configuration and TLS setup</p>
            </div>
            <div class="doc-item">
                <a href="../application/DEPLOY-2FA-APPS.md">Deploying the 2FA Application</a>
                <p>Complete step-by-step guide for deploying backend and frontend 2FA applications</p>
            </div>
            <div class="doc-item">
                <a href="../SECRETS_REQUIREMENTS.md">Secrets Requirements</a>
                <p>Complete guide for managing secrets via GitHub and AWS Secrets Manager</p>
            </div>
        </div>
        <h3 id="module-documentation">Module Documentation</h3>
        <div class="doc-grid">
            <div class="doc-item">
                <a href="../application/modules/alb/README.md">ALB Module</a>
                <p>EKS Auto Mode ALB configuration</p>
            </div>
            <div class="doc-item">
                <a href="../application/modules/argocd/README.md">ArgoCD Module</a>
                <p>AWS managed ArgoCD setup</p>
            </div>
            <div class="doc-item">
                <a href="../application/modules/argocd_app/README.md">ArgoCD Application Module</a>
                <p>GitOps application deployment</p>
            </div>
            <div class="doc-item">
                <a href="../application/modules/cert-manager/README.md">cert-manager Module</a>
                <p>TLS certificate management</p>
            </div>
            <div class="doc-item">
                <a href="../application/modules/network-policies/README.md">Network Policies Module</a>
                <p>Pod-to-pod security</p>
            </div>
            <div class="doc-item">
                <a href="../application/modules/postgresql/README.md">PostgreSQL Module</a>
                <p>User data and verification token storage</p>
            </div>
            <div class="doc-item">
                <a href="../application/modules/redis/README.md">Redis Module</a>
                <p>SMS OTP code storage</p>
            </div>
            <div class="doc-item">
                <a href="../application/modules/ses/README.md">SES Module</a>
                <p>Email verification and notifications</p>
            </div>
            <div class="doc-item">
                <a href="../application/modules/sns/README.md">SNS Module</a>
                <p>SMS 2FA integration</p>
            </div>
            <div class="doc-item">
                <a href="../application/modules/route53_record/README.md">Route53 Record Module</a>
                <p>Route53 A (alias) records for ALB</p>
            </div>
            <div class="doc-item">
                <a href="../backend_infra/modules/endpoints/README.md">VPC Endpoints Module</a>
                <p>Private AWS service access</p>
            </div>
            <div class="doc-item">
                <a href="../backend_infra/modules/ecr/README.md">ECR Module</a>
                <p>Container registry setup</p>
            </div>
            <div class="doc-item">
                <a href="../backend_infra/modules/ebs/README.md">EBS Module</a>
                <p>EBS storage configuration</p>
            </div>
        </div>
        <h3 id="configuration-documentation">Configuration Documentation</h3>
        <div class="doc-grid">
            <div class="doc-item">
                <a href="../application/PRD-ALB.md">ALB Configuration PRD</a>
                <p>Application Load Balancer configuration details</p>
            </div>
            <div class="doc-item">
                <a href="../application/PRD-ArgoCD.md">ArgoCD Configuration PRD</a>
                <p>GitOps deployment configuration</p>
            </div>
            <div class="doc-item">
                <a href="../application/PRD-DOMAIN.md">Domain Configuration PRD</a>
                <p>Route53 and domain setup</p>
            </div>
            <div class="doc-item">
                <a href="../application/PRD.md">Main PRD</a>
                <p>Application requirements document</p>
            </div>
        </div>
        <h3 id="security-operations">Security & Operations</h3>
        <div class="doc-grid">
            <div class="doc-item">
                <a href="../application/SECURITY-IMPROVEMENTS.md">Security Improvements</a>
                <p>Security enhancements and best practices</p>
            </div>
            <div class="doc-item">
                <a href="../CHANGELOG.md">Project Changelog</a>
                <p>All project changes including latest features and improvements</p>
            </div>
            <div class="doc-item">
                <a href="../backend_infra/CHANGELOG.md">Backend Infrastructure Changelog</a>
                <p>Backend infrastructure changes (VPC, EKS, IRSA, VPC endpoints)</p>
            </div>
            <div class="doc-item">
                <a href="../application/CHANGELOG.md">Application Infrastructure Changelog</a>
                <p>Application infrastructure changes (2FA app, OpenLDAP, supporting services)</p>
            </div>
            <div class="doc-item">
                <a href="../tf_backend_state/CHANGELOG.md">Terraform Backend State Changelog</a>
                <p>S3 state management changes (v1.0.0 with file-based locking)</p>
            </div>
        </div>
    </section>
    <!-- Access Information -->
    <section id="access">
        <h2>Accessing the Services</h2>
        <p>After deployment, the following services are available:</p>
        <h3 id="2fa-application-access">2FA Application</h3>
        <div class="card">
            <p><strong>URL:</strong> <code>https://app.&lt;your-domain&gt;</code> (e.g., <code>https://app.example.com</code>)</p>
            <p>The full-stack 2FA application provides:</p>
            <ul>
                <li>Self-service user registration with email/phone verification and profile state management (PENDING ‚Üí COMPLETE ‚Üí ACTIVE)</li>
                <li>Two-factor authentication enrollment and login with dual MFA methods (TOTP and SMS)</li>
                <li>TOTP setup with QR code generation for authenticator apps</li>
                <li>SMS verification with 6-digit OTP codes sent via AWS SNS</li>
                <li>User profile management with edit restrictions for verified fields</li>
                <li>Admin dashboard for user management, group CRUD operations, and approval workflows (visible to LDAP admin group members only)</li>
                <li><strong>Interactive API Documentation</strong> (always enabled):
                    <ul>
                        <li><code>/api/docs</code> - Swagger UI for interactive API exploration and testing</li>
                        <li><code>/api/redoc</code> - ReDoc alternative API documentation interface</li>
                        <li><code>/api/openapi.json</code> - OpenAPI schema in JSON format</li>
                    </ul>
                </li>
            </ul>
        </div>
        <h3 id="phpldapadmin-access">PhpLdapAdmin</h3>
        <div class="card">
            <p><strong>URL:</strong> <code>https://phpldapadmin.&lt;your-domain&gt;</code> (e.g., <code>https://phpldapadmin.example.com</code>)</p>
            <ul>
                <li>Web-based LDAP administration interface for managing directory entries</li>
                <li>Internet-facing access via Application Load Balancer with HTTPS/TLS termination</li>
                <li>Requires OpenLDAP admin credentials for authentication</li>
            </ul>
        </div>
        <h3 id="ltb-passwd-access">LTB-passwd</h3>
        <div class="card">
            <p><strong>URL:</strong> <code>https://passwd.&lt;your-domain&gt;</code> (e.g., <code>https://passwd.example.com</code>)</p>
            <ul>
                <li>Self-service password management UI for LDAP users</li>
                <li>Allows users to reset their LDAP passwords without administrator intervention</li>
                <li>Internet-facing access via Application Load Balancer with HTTPS/TLS termination</li>
            </ul>
        </div>
        <h3 id="argocd-access">ArgoCD</h3>
        <div class="card">
            <p><strong>URL:</strong> Retrieved from Terraform output <code>argocd_server_url</code> (if ArgoCD is enabled)</p>
            <ul>
                <li>AWS EKS managed ArgoCD service for GitOps deployments</li>
                <li>Declarative, Git-driven application deployments</li>
                <li>AWS Identity Center (SSO) authentication for secure access</li>
                <li>Automatic synchronization and self-healing capabilities</li>
            </ul>
        </div>
        <h3 id="ldap-service-access">LDAP Service</h3>
        <div class="card">
            <p><strong>Access:</strong> Cluster-internal only (ClusterIP service)</p>
            <ul>
                <li><strong>Port:</strong> 389 (LDAP), 636 (LDAPS)</li>
                <li><strong>Not Exposed:</strong> LDAP ports are not accessible outside the cluster</li>
            </ul>
        </div>
        <h3 id="mfa-methods">MFA Methods</h3>
        <table>
            <thead>
                <tr>
                    <th>Method</th>
                    <th>Description</th>
                    <th>Infrastructure Required</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>TOTP</strong></td>
                    <td>Time-based One-Time Password using authenticator apps (Google Authenticator, Authy, etc.)</td>
                    <td>None (codes generated locally)</td>
                </tr>
                <tr>
                    <td><strong>SMS</strong></td>
                    <td>Verification codes sent via AWS SNS to user's phone</td>
                    <td>SNS VPC endpoint, IRSA role</td>
                </tr>
            </tbody>
        </table>
    </section>
    <!-- Security Considerations -->
    <section id="security">
        <h2>Security Considerations</h2>
        <h3 id="key-security-features">Key Security Features</h3>
        <div class="card">
            <p>This project implements defense-in-depth security across multiple layers:</p>
            <ul>
                <li><strong>Secrets Management</strong>: Passwords managed via GitHub repository secrets (CI/CD) or AWS Secrets Manager (local) with automated retrieval‚Äînever committed to version control</li>
                <li><strong>IRSA (IAM Roles for Service Accounts)</strong>: Pods assume IAM roles via OIDC‚Äîno long-lived AWS credentials stored in containers or environment variables</li>
                <li><strong>VPC Endpoints</strong>: AWS service access (SSM, STS, SNS) routed through private endpoints‚Äîno public internet exposure for sensitive operations</li>
                <li><strong>TLS/HTTPS</strong>: TLS termination at ALB using ACM certificates; internal cluster communication secured via cert-manager</li>
                <li><strong>LDAP Security</strong>: ClusterIP service only (not exposed externally); cross-namespace access restricted to secure ports (443, 636, 8443)</li>
                <li><strong>Network Policies</strong>: Kubernetes Network Policies restrict pod-to-pod communication to encrypted ports with cross-namespace support for authorized services</li>
                <li><strong>Storage Encryption</strong>: EBS volumes encrypted by default; S3 state files encrypted with AES256 server-side encryption</li>
                <li><strong>Network Isolation</strong>: EKS nodes deployed in private subnets with no public IPs; access via SSM Session Manager</li>
                <li><strong>Multi-Account Architecture</strong>: State storage (Account A) isolated from resource deployment (Account B) for enhanced security and compliance</li>
                <li><strong>State Locking</strong>: S3 file-based locking prevents concurrent Terraform operations and state corruption</li>
                <li><strong>OIDC Authentication</strong>: GitHub Actions authenticates with AWS via OIDC‚Äîno access keys required</li>
                <li><strong>Cross-Account Security</strong>: ExternalId required for cross-account role assumption to prevent confused deputy attacks; bidirectional trust relationships</li>
                <li><strong>Helm Release Safety</strong>: Comprehensive Helm release attributes (atomic, force_update, replace, cleanup_on_fail, recreate_pods, wait, wait_for_jobs, upgrade_install) for safer deployments</li>
                <li><strong>ECR Image Support</strong>: All modules (OpenLDAP, PostgreSQL, Redis) use ECR images instead of Docker Hub to prevent rate limiting</li>
                <li><strong>Kubeconfig Auto-Update</strong>: Automatic kubeconfig updates prevent stale cluster endpoints and DNS lookup errors</li>
            </ul>
            <p><strong>For detailed security documentation:</strong> <a href="../application/SECURITY-IMPROVEMENTS.md">Security Improvements</a></p>
        </div>
    </section>
    <!-- Contributing & Support -->
    <section id="support">
        <h2>Contributing & Support</h2>
        <h3 id="operations-monitoring">Operations & Monitoring</h3>
        <div class="card">
            <h4>Deployment Monitoring Script</h4>
            <p>The project includes a comprehensive monitoring script (<code>monitor-deployments.sh</code>) located in the project root that provides health checks for all deployed components.</p>
            <h5>Features</h5>
            <ul>
                <li><strong>Interactive Setup:</strong> Prompts for AWS region and environment (prod/dev)</li>
                <li><strong>Automatic Configuration:</strong> Retrieves role ARNs and ExternalId from AWS Secrets Manager</li>
                <li><strong>Cluster Access:</strong> Automatically retrieves cluster name from Terraform state and updates kubeconfig</li>
                <li><strong>Comprehensive Health Checks:</strong>
                    <ul>
                        <li>ArgoCD capability status (if enabled)</li>
                        <li>OpenLDAP Helm release and pod status</li>
                        <li>PostgreSQL Helm release and pod status</li>
                        <li>Redis Helm release and pod status</li>
                        <li>Ingress resources across all namespaces</li>
                        <li>Application Load Balancer status</li>
                    </ul>
                </li>
                <li><strong>Color-Coded Output:</strong> Green for success, yellow for warnings, red for errors</li>
                <li><strong>Summary Report:</strong> Overall deployment health status with exit codes</li>
            </ul>
            <h5>Usage</h5>
            <pre><code>./monitor-deployments.sh</code></pre>
            <p>The script will prompt for region and environment, then automatically perform all health checks and display a summary.</p>
            <h5>Prerequisites</h5>
            <ul>
                <li><code>jq</code> command-line tool installed</li>
                <li><code>kubectl</code> and <code>helm</code> installed</li>
                <li>AWS CLI configured with permissions to:
                    <ul>
                        <li>Access AWS Secrets Manager</li>
                        <li>Assume IAM roles in deployment accounts</li>
                        <li>Access S3 bucket containing Terraform state</li>
                        <li>Access EKS cluster</li>
                    </ul>
                </li>
                <li>GitHub CLI (<code>gh</code>) installed (optional, for retrieving backend bucket name)</li>
            </ul>
            <h5>Exit Codes</h5>
            <ul>
                <li><code>0</code>: All deployments are healthy</li>
                <li><code>1</code>: Some deployments have issues (check output for details)</li>
            </ul>
            <h5>Example Output</h5>
            <pre><code>=========================================
Monitoring Deployments for prod in us-east-1
=========================================

‚úì Retrieved State Account role ARN
‚úì Retrieved Deployment Account role ARN (production)
‚úì Successfully assumed Deployment Account role
‚úì Cluster name: my-cluster-prod
‚úì Kubeconfig updated successfully

=========================================
Checking ArgoCD Capability
=========================================
ArgoCD pods: 3/3 running
‚úì ArgoCD is deployed and running

=========================================
Monitoring Summary
=========================================
‚úì All deployments are healthy!</code></pre>
            <p><strong>For detailed documentation:</strong> See <a href="../README.md#operations--monitoring">Operations & Monitoring</a> in the main README.</p>
        </div>
        <h3 id="troubleshooting">Troubleshooting</h3>
        <div class="card">
            <p>For troubleshooting guides, see:</p>
            <ul>
                <li><a href="../backend_infra/README.md#troubleshooting">Backend Infrastructure Troubleshooting</a></li>
                <li><a href="../application/README.md#troubleshooting">Application Infrastructure Troubleshooting</a></li>
            </ul>
        </div>
        <h3 id="repository">Repository</h3>
        <div class="card">
            <p>GitHub Repository: <a href="https://github.com/talorlik/ldap-2fa-on-k8s" target="_blank">ldap-2fa-on-k8s</a></p>
        </div>
        <h3 id="license">License</h3>
        <div class="card">
            <p>This project is licensed under the <strong>MIT License</strong>.</p>
            <p>See the <a href="../LICENSE">LICENSE</a> file for details.</p>
            <p>Copyright (c) 2025 Tal Orlik</p>
        </div>
    </section>
    <!-- Footer -->
    <footer>
        <p>&copy; 2025 Tal Orlik. Licensed under MIT License.</p>
        <p>LDAP Authentication with 2FA on Kubernetes (EKS)</p>
    </footer>
    <script>
        // Theme management
        const themeStylesheet = document.getElementById('theme-stylesheet');
        const themeToggle = document.getElementById('themeToggle');
        const sunIcon = document.getElementById('sunIcon');
        const moonIcon = document.getElementById('moonIcon');
        // Get saved theme or default to light
        const currentTheme = localStorage.getItem('theme') || 'light';
        function setTheme(theme) {
            if (theme === 'dark') {
                themeStylesheet.href = 'dark-theme.css';
                // Show sun icon (to switch to light theme)
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
                themeToggle.setAttribute('aria-label', 'Switch to light theme');
                themeToggle.setAttribute('title', 'Switch to light theme');
                localStorage.setItem('theme', 'dark');
            } else {
                themeStylesheet.href = 'light-theme.css';
                // Show moon icon (to switch to dark theme)
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
                themeToggle.setAttribute('aria-label', 'Switch to dark theme');
                themeToggle.setAttribute('title', 'Switch to dark theme');
                localStorage.setItem('theme', 'light');
            }
        }
        // Initialize theme on page load
        setTheme(currentTheme);
        // Toggle theme on button click
        themeToggle.addEventListener('click', () => {
            const newTheme = themeStylesheet.href.includes('dark-theme.css') ? 'light' : 'dark';
            setTheme(newTheme);
        });
        // Mobile menu toggle
        const mobileMenuToggle = document.getElementById('mobileMenuToggle');
        const navMenu = document.getElementById('navMenu');
        mobileMenuToggle.addEventListener('click', () => {
            navMenu.classList.toggle('active');
        });
        // Close mobile menu when clicking on a link
        const navLinks = document.querySelectorAll('.nav-menu a');
        navLinks.forEach(link => {
            link.addEventListener('click', () => {
                navMenu.classList.remove('active');
            });
        });
        // Active section highlighting
        const sections = document.querySelectorAll('section[id]');
        const navLinksArray = Array.from(navLinks);
        function highlightActiveSection() {
            const scrollY = window.pageYOffset;
            sections.forEach(section => {
                const sectionHeight = section.offsetHeight;
                const sectionTop = section.offsetTop - 150;
                const sectionId = section.getAttribute('id');
                if (scrollY > sectionTop && scrollY <= sectionTop + sectionHeight) {
                    navLinksArray.forEach(link => {
                        link.classList.remove('active');
                        if (link.getAttribute('href') === `#${sectionId}`) {
                            link.classList.add('active');
                        }
                    });
                }
            });
        }
        window.addEventListener('scroll', highlightActiveSection);
        window.addEventListener('load', highlightActiveSection);
    </script>
    <!-- Scroll to Top Button -->
    <button id="scrollToTopButton" class="scroll-to-top" aria-label="Scroll to top" title="Scroll to top">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="10"></circle>
            <polyline points="16 12 12 8 8 12"></polyline>
            <line x1="12" y1="8" x2="12" y2="16"></line>
        </svg>
    </button>
    <script>
        // Initialize scroll to top button after DOM is ready
        function initScrollToTop() {
            const scrollToTopButton = document.getElementById('scrollToTopButton');
            if (!scrollToTopButton) {
                console.error('Scroll to top button not found');
                return;
            }
            // Check scroll position on load
            function checkScroll() {
                if (window.pageYOffset > 100 || document.documentElement.scrollTop > 100) {
                    scrollToTopButton.classList.add('visible');
                } else {
                    scrollToTopButton.classList.remove('visible');
                }
            }
            // Initial check
            checkScroll();
            // Handle scroll events
            window.addEventListener('scroll', checkScroll);
            // Handle click
            scrollToTopButton.addEventListener('click', (e) => {
                e.preventDefault();
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            });
        }
        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initScrollToTop);
        } else {
            initScrollToTop();
        }
        // Smooth scroll for anchor links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
    </script>
</body>
</html>