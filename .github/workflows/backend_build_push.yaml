name: Backend Build and Push

# This workflow can run in parallel with frontend_build_push.yaml since they modify
# different files (backend vs frontend values.yaml). The git operations include
# fetch/rebase and retry logic to handle concurrent pushes gracefully.

on:
  # push:
  #   branches:
  #     - main
  #   paths:
  #     - 'application/backend/**'
  #     - '.github/workflows/backend_build_push.yaml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Select Environment'
        required: true
        type: choice
        default: prod
        options:
          - prod
          - dev

env:
  AWS_REGION: us-east-1
  IMAGE_NAME: ldap-2fa-backend

jobs:
  BuildAndPush:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}

    steps:
      - name: Checkout the repo code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0  # Fetch full history for proper git operations

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_PRODUCTION_ACCOUNT_ROLE_ARN }}
          role-session-name: GitHubActions-BackendBuildPush
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get ECR Repository URL
        id: ecr-info
        run: |
          # Get ECR repository name from GitHub variable (set by backend_infra provisioning)
          ECR_REPO_NAME="${{ vars.ECR_REPOSITORY_NAME }}"
          if [ -z "$ECR_REPO_NAME" ]; then
            echo "❌ Error: ECR_REPOSITORY_NAME GitHub variable is not set or is empty"
            echo "   This variable is automatically set when you provision backend infrastructure."
            echo "   Please run the 'Backend Infra Provisioning' workflow or setup-backend.sh script first."
            exit 1
          fi
          ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"
          echo "ecr_registry=${ECR_REGISTRY}" >> $GITHUB_OUTPUT
          echo "ecr_repo_name=${ECR_REPO_NAME}" >> $GITHUB_OUTPUT
          echo "ecr_repo_url=${ECR_REGISTRY}/${ECR_REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Build, tag, and push Docker image
        id: build
        working-directory: ./application/backend
        run: |
          # Generate image tag: commit SHA + run ID so re-runs get a unique tag (ECR tags are immutable)
          IMAGE_TAG="${{ env.IMAGE_NAME }}-${{ github.sha }}-${{ github.run_id }}"

          # Build the Docker image
          docker build -t ${{ steps.ecr-info.outputs.ecr_repo_url }}:${IMAGE_TAG} .

          # Push to ECR
          docker push ${{ steps.ecr-info.outputs.ecr_repo_url }}:${IMAGE_TAG}

          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "full_image=${{ steps.ecr-info.outputs.ecr_repo_url }}:${IMAGE_TAG}" >> $GITHUB_OUTPUT

          echo "✅ Pushed image: ${{ steps.ecr-info.outputs.ecr_repo_url }}:${IMAGE_TAG}"

      - name: Update Helm values with new image
        run: |
          # Update the values.yaml with new image repository and tag
          VALUES_FILE="application/backend/helm/ldap-2fa-backend/values.yaml"

          # Update image repository
          sed -i "s|^  repository:.*|  repository: \"${{ steps.ecr-info.outputs.ecr_repo_url }}\"|" ${VALUES_FILE}

          # Update image tag
          sed -i "s|^  tag:.*|  tag: \"${{ steps.build.outputs.image_tag }}\"|" ${VALUES_FILE}

          echo "✅ Updated ${VALUES_FILE} with new image:"
          grep -A 3 "^image:" ${VALUES_FILE}

      - name: Commit and push changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          VALUES_FILE="application/backend/helm/ldap-2fa-backend/values.yaml"

          # Check if there are changes to commit
          if git diff --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          # Save the file content before any git operations
          # This ensures we can re-apply changes if rebase fails
          cat "${VALUES_FILE}" > /tmp/values_backup.yaml

          # Stage and commit the changes first
          git add "${VALUES_FILE}"
          git commit -m "chore(backend): update image tag to ${{ steps.build.outputs.image_tag }}

          Automated update by GitHub Actions workflow.
          Commit: ${{ github.sha }}
          "

          # Fetch latest changes and rebase our commit on top
          # This handles parallel workflow runs where another workflow may have pushed
          echo "Fetching latest changes from remote..."
          git fetch origin main

          # Rebase our commit on top of the latest remote changes
          # Since workflows modify different files, this should succeed without conflicts
          if ! git rebase origin/main; then
            echo "⚠️ Rebase failed, resetting and re-applying changes..."
            git rebase --abort || true
            git reset --hard origin/main
            git checkout main
            # Restore our changes from backup
            cp /tmp/values_backup.yaml "${VALUES_FILE}"
            git add "${VALUES_FILE}"
            git commit -m "chore(backend): update image tag to ${{ steps.build.outputs.image_tag }}

          Automated update by GitHub Actions workflow.
          Commit: ${{ github.sha }}
          "
          fi

          # Push changes with retry logic to handle parallel workflow runs
          MAX_RETRIES=3
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if git push origin main; then
              echo "✅ Changes committed and pushed successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "⚠️ Push failed, fetching latest changes and retrying (attempt $RETRY_COUNT/$MAX_RETRIES)..."
                git fetch origin main
                if ! git rebase origin/main; then
                  echo "⚠️ Rebase conflict during retry, resetting and re-applying..."
                  git rebase --abort || true
                  git reset --hard origin/main
                  git checkout main
                  # Restore our changes from backup
                  cp /tmp/values_backup.yaml "${VALUES_FILE}"
                  git add "${VALUES_FILE}"
                  git commit -m "chore(backend): update image tag to ${{ steps.build.outputs.image_tag }}

          Automated update by GitHub Actions workflow.
          Commit: ${{ github.sha }}
          "
                fi
                sleep 2
              else
                echo "❌ Failed to push after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

  Summary:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    needs: BuildAndPush
    if: success()
    steps:
      - name: Build Summary
        run: |
          echo "## Backend Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ **Image Tag:** ${{ needs.BuildAndPush.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
          echo "- If ArgoCD Applications are registered, they will automatically detect the git changes and sync the deployment." >> $GITHUB_STEP_SUMMARY
          echo "- For manual deployment, use the image tag above with Helm." >> $GITHUB_STEP_SUMMARY
